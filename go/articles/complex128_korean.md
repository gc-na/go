<!--
Meta Description: # Go 언어의 complex128 데이터 타입 ## 개요 Go 언어에서 `complex128`은 복소수(complex number)를 표현하기 위한 데이터 타입으로, 실수부와 허수부 각각이 `float64` 타입인 128비트 복소수를 나타냅니다. 이는 수학적 계산, ...
Meta Keywords: complex128, 복소수, 실수부와, float64, real
-->

# Go 언어의 complex128 데이터 타입

## 개요
Go 언어에서 `complex128`은 복소수(complex number)를 표현하기 위한 데이터 타입으로, 실수부와 허수부 각각이 `float64` 타입인 128비트 복소수를 나타냅니다. 이는 수학적 계산, 신호 처리 및 과학적 시뮬레이션 등 다양한 분야에서 유용하게 사용됩니다.

## 문서화
`complex128` 타입은 Go 언어의 내장 데이터 타입 중 하나로, 실수부와 허수부로 구성됩니다. 두 개의 `float64` 값을 사용하여 하나의 복소수를 나타내며, 복소수 연산을 위한 여러 내장 함수도 지원합니다.

### 사용법
- 복소수 생성: `complex(real, imag)` 함수를 사용하여 복소수를 생성할 수 있습니다.
- 연산: `+`, `-`, `*`, `/` 등의 연산자를 통해 복소수 간의 기본적인 산술 연산을 수행할 수 있습니다.
- 내장 함수: `real()`, `imag()` 함수를 사용하여 복소수의 실수부와 허수부를 각각 가져올 수 있습니다.

### 세부사항
- `complex128` 타입은 Go의 기본 자료형이므로 별도의 import가 필요하지 않습니다.
- 메모리 상에서 `complex128`은 16바이트를 차지합니다.
- 복소수의 실수부와 허수부는 각각 `float64` 타입으로 저장되며, 이는 수치 계산의 정확성을 보장합니다.

## 예제
```go
package main

import (
    "fmt"
)

func main() {
    // 복소수 생성
    z1 := complex(1.0, 2.0) // 1 + 2i
    z2 := complex(3.0, 4.0) // 3 + 4i

    // 복소수 덧셈
    sum := z1 + z2
    fmt.Println("Sum:", sum) // 출력: Sum: (4+6i)

    // 복소수 곱셈
    product := z1 * z2
    fmt.Println("Product:", product) // 출력: Product: (-5+10i)

    // 실수부와 허수부 가져오기
    fmt.Println("Real part:", real(z1)) // 출력: Real part: 1
    fmt.Println("Imaginary part:", imag(z1)) // 출력: Imaginary part: 2
}
```

## 설명
`complex128`을 사용할 때 주의할 점은 다음과 같습니다:
- 복소수 연산의 결과는 항상 `complex128` 타입입니다.
- 실수부와 허수부가 `float64`이므로, 이들 간의 연산에서 발생할 수 있는 부동 소수점 오차에 유의해야 합니다.
- 수학적 함수(예: 제곱근, 로그)는 복소수에 대해 정의되어 있지 않거나, 특정 조건 하에서만 사용될 수 있습니다. 따라서 사용 시 주의가 필요합니다.

## 한 줄 요약
Go 언어에서 `complex128`은 128비트 복소수를 표현하는 데이터 타입으로, 실수부와 허수부 각각이 `float64` 타입으로 구성되어 있습니다.