<!--
Meta Description: # Go言語の「chan」：ゴルーチン間の通信をサポートするチャネル ## 概要 Go言語の「chan」は、ゴルーチン間でデータを安全に通信するためのメカニズムです。チャネルを使用することで、複数のゴルーチンがデータをやり取りし、並行処理を効率的に行うことができます。 ## ドキュメンテーション 「...
Meta Keywords: chan, make, go言語の, func, time
-->

# Go言語の「chan」：ゴルーチン間の通信をサポートするチャネル

## 概要
Go言語の「chan」は、ゴルーチン間でデータを安全に通信するためのメカニズムです。チャネルを使用することで、複数のゴルーチンがデータをやり取りし、並行処理を効率的に行うことができます。

## ドキュメンテーション
「chan」は、Go言語における並行処理の中心的な要素です。チャネルは、特定の型のデータを送受信するために使用され、以下のような特徴を持っています。

### 目的
- ゴルーチン間の通信を簡略化し、安全にデータをやり取りする。
- データの送信と受信を同期的に行うことで、排他制御を実現する。

### 使用法
チャネルの基本的な宣言と使用法は以下の通りです。

```go
// チャネルの宣言
ch := make(chan int)

// データの送信
go func() {
    ch <- 42 // チャネルに値を送信
}()

// データの受信
value := <-ch // チャネルから値を受信
```

### 詳細
- チャネルは、`make`関数を使用して作成されます。
- デフォルトでは、チャネルはバッファなし（無限待機）で、送信と受信の両方が行われるまで処理がブロックされます。
- バッファ付きチャネルを作成するには、`make(chan type, capacity)`のように、容量を指定します。

## 例
以下に、基本的なチャネルの使用例を示します。

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        ch <- "Hello, Go!"
    }()

    message := <-ch
    fmt.Println(message)
}
```

このプログラムでは、1秒待機した後、ゴルーチンがチャネルを通じてメッセージを送信します。

## 説明
- **一般的な落とし穴**: チャネルを閉じる際に注意が必要です。チャネルを閉じた後に送信を試みると、ランタイムエラーが発生します。また、閉じたチャネルからの受信は、ゼロ値を返します。
- **デッドロック**: チャネルを使用する際に、適切にデータを送受信しないと、デッドロックが発生する可能性があります。特に、バッファなしのチャネルでは、送信と受信が必ず対になる必要があります。

## 一文要約
Go言語の「chan」は、ゴルーチン間での安全なデータ通信を可能にする強力なメカニズムです。